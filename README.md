Java 网络通讯模型（BIO、NIO、AIO、Netty综合示例）
    
# 本次的案例
采用一个标准的ECHO程序，客户端输入一个内容，随后服务器端接收到之后进行数据简单操作并返回响应。

##【JDK 1.0】BIO
同步阻塞IO操作，每一个线程都只会管理一个客户端的链接，这种操作的本质是存在有程序阻塞的问题。
线程的资源总是在不断的进行创建，并且所有的数据接收里面（Scanner、PrintStream简化了），网络的数据都是长度限制的，传统的数据是需要通过字节数组的形式搬砖完成的。
BIO：是需要对数据采用蚂蚁搬家的模式完成的。
程序问题：性能不高、多线程的利用率不高、如果大规模的用户访问，有可能会造成服务器端资源耗尽。

##【JDK 1.4】NIO
提供有了一个java.nio的开发包，从这一时代开始，Java提升了IO的处理效率，同时也提升网络模型的处理效率，同时NIO里面采用的是同步非阻塞IO操作。
NIO的出现在当时来讲，给Java带来了一个最伟大的通讯利器（已经接近于底层的传输性能）。
NIO里面提倡使用Buffer来代替传统的数组操作（蚂蚁搬家），可以减少数组的操作复杂度，利用缓存数据的保存与方便的清空操作进行处理。
Reactor模型提倡的是：公共注册，统一操作，所以会提供有一系列的Channel（通道）。

##【JDK 1.7】AIO
异步非阻塞IO通讯，需要采用大量的回调处理模式，所以需要使用：public interface CompletionHandler<V,A>

# 总结

- BIO（同步阻塞IO）
> 在进行处理的时候是通过一个线程进行操作，并且IO实现通讯的时候采用的是阻塞模式；你现在通过水壶烧水，在BIO的世界里面，烧水这一过程你需要从头一直监视到结尾；
   
- NIO（同步非阻塞IO)
> 不断的进行烧水状态的判断，同时你可以做其他的事情；
    
- AIO（异步非阻塞IO)
> 烧水的过程你不用关注，如果水一旦烧好了，就会给你一个反馈。
 
AIO在Java中的使用并不广泛，基于纯异步的回调了解即可。

NIO虽然理念良好，解决了很多问题，但JAVA NIO的API设计不得不说非常令人吐槽，陷阱非常多，实践中不推荐直接使用Java NIO进行开发。

Netty作为一个广泛使用的Java开源网络通信框架，完全实现了reactor模型，基于NIO但做了很多优化和改良，大大简化了开发人员的使用门槛；在许多著名项目中都有使用，如dubbo、zookeeper、rocketmq等等。